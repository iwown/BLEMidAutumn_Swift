// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: files_update.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum FUType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case gps // = 0
  case font // = 1
  case mgaonline // = 2
  case customdial // = 3
  case firmware // = 4

  init() {
    self = .gps
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .gps
    case 1: self = .font
    case 2: self = .mgaonline
    case 3: self = .customdial
    case 4: self = .firmware
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .gps: return 0
    case .font: return 1
    case .mgaonline: return 2
    case .customdial: return 3
    case .firmware: return 4
    }
  }

}

#if swift(>=4.2)

extension FUType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct FUInitResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fd: FUType {
    get {return _fd ?? .gps}
    set {_fd = newValue}
  }
  /// Returns true if `fd` has been explicitly set.
  var hasFd: Bool {return self._fd != nil}
  /// Clears the value of `fd`. Subsequent reads from it will return its default value.
  mutating func clearFd() {self._fd = nil}

  var status: FUInitResponse.Status {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case errorParams // = 1
    case errorInner // = 2

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .errorParams
      case 2: self = .errorInner
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .errorParams: return 1
      case .errorInner: return 2
      }
    }

  }

  init() {}

  fileprivate var _fd: FUType? = nil
  fileprivate var _status: FUInitResponse.Status? = nil
}

#if swift(>=4.2)

extension FUInitResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct FUDataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fd: FUType {
    get {return _fd ?? .gps}
    set {_fd = newValue}
  }
  /// Returns true if `fd` has been explicitly set.
  var hasFd: Bool {return self._fd != nil}
  /// Clears the value of `fd`. Subsequent reads from it will return its default value.
  mutating func clearFd() {self._fd = nil}

  var status: FUDataResponse.Status {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var fileOffset: UInt32 {
    get {return _fileOffset ?? 0}
    set {_fileOffset = newValue}
  }
  /// Returns true if `fileOffset` has been explicitly set.
  var hasFileOffset: Bool {return self._fileOffset != nil}
  /// Clears the value of `fileOffset`. Subsequent reads from it will return its default value.
  mutating func clearFileOffset() {self._fileOffset = nil}

  var crc32AtOffset: UInt32 {
    get {return _crc32AtOffset ?? 0}
    set {_crc32AtOffset = newValue}
  }
  /// Returns true if `crc32AtOffset` has been explicitly set.
  var hasCrc32AtOffset: Bool {return self._crc32AtOffset != nil}
  /// Clears the value of `crc32AtOffset`. Subsequent reads from it will return its default value.
  mutating func clearCrc32AtOffset() {self._crc32AtOffset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case errorParams // = 1
    case errorOffsetMismatch // = 2
    case errorCrc32Mismatch // = 3
    case errorInner // = 4

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .errorParams
      case 2: self = .errorOffsetMismatch
      case 3: self = .errorCrc32Mismatch
      case 4: self = .errorInner
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .errorParams: return 1
      case .errorOffsetMismatch: return 2
      case .errorCrc32Mismatch: return 3
      case .errorInner: return 4
      }
    }

  }

  init() {}

  fileprivate var _fd: FUType? = nil
  fileprivate var _status: FUDataResponse.Status? = nil
  fileprivate var _fileOffset: UInt32? = nil
  fileprivate var _crc32AtOffset: UInt32? = nil
}

#if swift(>=4.2)

extension FUDataResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct FUFileInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fd: FUType {
    get {return _fd ?? .gps}
    set {_fd = newValue}
  }
  /// Returns true if `fd` has been explicitly set.
  var hasFd: Bool {return self._fd != nil}
  /// Clears the value of `fd`. Subsequent reads from it will return its default value.
  mutating func clearFd() {self._fd = nil}

  var fileName: String {
    get {return _fileName ?? String()}
    set {_fileName = newValue}
  }
  /// Returns true if `fileName` has been explicitly set.
  var hasFileName: Bool {return self._fileName != nil}
  /// Clears the value of `fileName`. Subsequent reads from it will return its default value.
  mutating func clearFileName() {self._fileName = nil}

  var fileSize: UInt32 {
    get {return _fileSize ?? 0}
    set {_fileSize = newValue}
  }
  /// Returns true if `fileSize` has been explicitly set.
  var hasFileSize: Bool {return self._fileSize != nil}
  /// Clears the value of `fileSize`. Subsequent reads from it will return its default value.
  mutating func clearFileSize() {self._fileSize = nil}

  var fileCrc32: UInt32 {
    get {return _fileCrc32 ?? 0}
    set {_fileCrc32 = newValue}
  }
  /// Returns true if `fileCrc32` has been explicitly set.
  var hasFileCrc32: Bool {return self._fileCrc32 != nil}
  /// Clears the value of `fileCrc32`. Subsequent reads from it will return its default value.
  mutating func clearFileCrc32() {self._fileCrc32 = nil}

  var fileOffset: UInt32 {
    get {return _fileOffset ?? 0}
    set {_fileOffset = newValue}
  }
  /// Returns true if `fileOffset` has been explicitly set.
  var hasFileOffset: Bool {return self._fileOffset != nil}
  /// Clears the value of `fileOffset`. Subsequent reads from it will return its default value.
  mutating func clearFileOffset() {self._fileOffset = nil}

  var crc32AtOffset: UInt32 {
    get {return _crc32AtOffset ?? 0}
    set {_crc32AtOffset = newValue}
  }
  /// Returns true if `crc32AtOffset` has been explicitly set.
  var hasCrc32AtOffset: Bool {return self._crc32AtOffset != nil}
  /// Clears the value of `crc32AtOffset`. Subsequent reads from it will return its default value.
  mutating func clearCrc32AtOffset() {self._crc32AtOffset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fd: FUType? = nil
  fileprivate var _fileName: String? = nil
  fileprivate var _fileSize: UInt32? = nil
  fileprivate var _fileCrc32: UInt32? = nil
  fileprivate var _fileOffset: UInt32? = nil
  fileprivate var _crc32AtOffset: UInt32? = nil
}

struct FUFileDesc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var maxSize: UInt32 {
    get {return _storage._maxSize ?? 0}
    set {_uniqueStorage()._maxSize = newValue}
  }
  /// Returns true if `maxSize` has been explicitly set.
  var hasMaxSize: Bool {return _storage._maxSize != nil}
  /// Clears the value of `maxSize`. Subsequent reads from it will return its default value.
  mutating func clearMaxSize() {_uniqueStorage()._maxSize = nil}

  var valid: Bool {
    get {return _storage._valid ?? false}
    set {_uniqueStorage()._valid = newValue}
  }
  /// Returns true if `valid` has been explicitly set.
  var hasValid: Bool {return _storage._valid != nil}
  /// Clears the value of `valid`. Subsequent reads from it will return its default value.
  mutating func clearValid() {_uniqueStorage()._valid = nil}

  var info: FUFileInfo {
    get {return _storage._info ?? FUFileInfo()}
    set {_uniqueStorage()._info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return _storage._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {_uniqueStorage()._info = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct FUExitResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fd: FUType {
    get {return _storage._fd ?? .gps}
    set {_uniqueStorage()._fd = newValue}
  }
  /// Returns true if `fd` has been explicitly set.
  var hasFd: Bool {return _storage._fd != nil}
  /// Clears the value of `fd`. Subsequent reads from it will return its default value.
  mutating func clearFd() {_uniqueStorage()._fd = nil}

  var status: FUExitResponse.Status {
    get {return _storage._status ?? .ok}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var desc: FUFileDesc {
    get {return _storage._desc ?? FUFileDesc()}
    set {_uniqueStorage()._desc = newValue}
  }
  /// Returns true if `desc` has been explicitly set.
  var hasDesc: Bool {return _storage._desc != nil}
  /// Clears the value of `desc`. Subsequent reads from it will return its default value.
  mutating func clearDesc() {_uniqueStorage()._desc = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case errorParams // = 1
    case errorCrcMismatch // = 2
    case errorSizeMismatch // = 3
    case errorInner // = 4

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .errorParams
      case 2: self = .errorCrcMismatch
      case 3: self = .errorSizeMismatch
      case 4: self = .errorInner
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .errorParams: return 1
      case .errorCrcMismatch: return 2
      case .errorSizeMismatch: return 3
      case .errorInner: return 4
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension FUExitResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct FUDescResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mtu: UInt32 {
    get {return _storage._mtu ?? 0}
    set {_uniqueStorage()._mtu = newValue}
  }
  /// Returns true if `mtu` has been explicitly set.
  var hasMtu: Bool {return _storage._mtu != nil}
  /// Clears the value of `mtu`. Subsequent reads from it will return its default value.
  mutating func clearMtu() {_uniqueStorage()._mtu = nil}

  var gps: FUFileDesc {
    get {return _storage._gps ?? FUFileDesc()}
    set {_uniqueStorage()._gps = newValue}
  }
  /// Returns true if `gps` has been explicitly set.
  var hasGps: Bool {return _storage._gps != nil}
  /// Clears the value of `gps`. Subsequent reads from it will return its default value.
  mutating func clearGps() {_uniqueStorage()._gps = nil}

  var font: FUFileDesc {
    get {return _storage._font ?? FUFileDesc()}
    set {_uniqueStorage()._font = newValue}
  }
  /// Returns true if `font` has been explicitly set.
  var hasFont: Bool {return _storage._font != nil}
  /// Clears the value of `font`. Subsequent reads from it will return its default value.
  mutating func clearFont() {_uniqueStorage()._font = nil}

  var mgaonline: FUFileDesc {
    get {return _storage._mgaonline ?? FUFileDesc()}
    set {_uniqueStorage()._mgaonline = newValue}
  }
  /// Returns true if `mgaonline` has been explicitly set.
  var hasMgaonline: Bool {return _storage._mgaonline != nil}
  /// Clears the value of `mgaonline`. Subsequent reads from it will return its default value.
  mutating func clearMgaonline() {_uniqueStorage()._mgaonline = nil}

  var customdial: FUFileDesc {
    get {return _storage._customdial ?? FUFileDesc()}
    set {_uniqueStorage()._customdial = newValue}
  }
  /// Returns true if `customdial` has been explicitly set.
  var hasCustomdial: Bool {return _storage._customdial != nil}
  /// Clears the value of `customdial`. Subsequent reads from it will return its default value.
  mutating func clearCustomdial() {_uniqueStorage()._customdial = nil}

  var firmware: FUFileDesc {
    get {return _storage._firmware ?? FUFileDesc()}
    set {_uniqueStorage()._firmware = newValue}
  }
  /// Returns true if `firmware` has been explicitly set.
  var hasFirmware: Bool {return _storage._firmware != nil}
  /// Clears the value of `firmware`. Subsequent reads from it will return its default value.
  mutating func clearFirmware() {_uniqueStorage()._firmware = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct FilesUpdateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var params: OneOf_Params? {
    get {return _storage._params}
    set {_uniqueStorage()._params = newValue}
  }

  var init_p: FUInitResponse {
    get {
      if case .init_p(let v)? = _storage._params {return v}
      return FUInitResponse()
    }
    set {_uniqueStorage()._params = .init_p(newValue)}
  }

  var data: FUDataResponse {
    get {
      if case .data(let v)? = _storage._params {return v}
      return FUDataResponse()
    }
    set {_uniqueStorage()._params = .data(newValue)}
  }

  var exit: FUExitResponse {
    get {
      if case .exit(let v)? = _storage._params {return v}
      return FUExitResponse()
    }
    set {_uniqueStorage()._params = .exit(newValue)}
  }

  var desc: FUDescResponse {
    get {
      if case .desc(let v)? = _storage._params {return v}
      return FUDescResponse()
    }
    set {_uniqueStorage()._params = .desc(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Params: Equatable {
    case init_p(FUInitResponse)
    case data(FUDataResponse)
    case exit(FUExitResponse)
    case desc(FUDescResponse)

  #if !swift(>=4.1)
    static func ==(lhs: FilesUpdateResponse.OneOf_Params, rhs: FilesUpdateResponse.OneOf_Params) -> Bool {
      switch (lhs, rhs) {
      case (.init_p(let l), .init_p(let r)): return l == r
      case (.data(let l), .data(let r)): return l == r
      case (.exit(let l), .exit(let r)): return l == r
      case (.desc(let l), .desc(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct FUInitRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var initInfo: FUFileInfo {
    get {return _storage._initInfo ?? FUFileInfo()}
    set {_uniqueStorage()._initInfo = newValue}
  }
  /// Returns true if `initInfo` has been explicitly set.
  var hasInitInfo: Bool {return _storage._initInfo != nil}
  /// Clears the value of `initInfo`. Subsequent reads from it will return its default value.
  mutating func clearInitInfo() {_uniqueStorage()._initInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct FUDataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fd: FUType {
    get {return _fd ?? .gps}
    set {_fd = newValue}
  }
  /// Returns true if `fd` has been explicitly set.
  var hasFd: Bool {return self._fd != nil}
  /// Clears the value of `fd`. Subsequent reads from it will return its default value.
  mutating func clearFd() {self._fd = nil}

  var fileOffset: UInt32 {
    get {return _fileOffset ?? 0}
    set {_fileOffset = newValue}
  }
  /// Returns true if `fileOffset` has been explicitly set.
  var hasFileOffset: Bool {return self._fileOffset != nil}
  /// Clears the value of `fileOffset`. Subsequent reads from it will return its default value.
  mutating func clearFileOffset() {self._fileOffset = nil}

  var crc32AtOffset: UInt32 {
    get {return _crc32AtOffset ?? 0}
    set {_crc32AtOffset = newValue}
  }
  /// Returns true if `crc32AtOffset` has been explicitly set.
  var hasCrc32AtOffset: Bool {return self._crc32AtOffset != nil}
  /// Clears the value of `crc32AtOffset`. Subsequent reads from it will return its default value.
  mutating func clearCrc32AtOffset() {self._crc32AtOffset = nil}

  var buf: Data {
    get {return _buf ?? SwiftProtobuf.Internal.emptyData}
    set {_buf = newValue}
  }
  /// Returns true if `buf` has been explicitly set.
  var hasBuf: Bool {return self._buf != nil}
  /// Clears the value of `buf`. Subsequent reads from it will return its default value.
  mutating func clearBuf() {self._buf = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fd: FUType? = nil
  fileprivate var _fileOffset: UInt32? = nil
  fileprivate var _crc32AtOffset: UInt32? = nil
  fileprivate var _buf: Data? = nil
}

struct FUExitRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fd: FUType {
    get {return _fd ?? .gps}
    set {_fd = newValue}
  }
  /// Returns true if `fd` has been explicitly set.
  var hasFd: Bool {return self._fd != nil}
  /// Clears the value of `fd`. Subsequent reads from it will return its default value.
  mutating func clearFd() {self._fd = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fd: FUType? = nil
}

struct FilesUpdateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var params: OneOf_Params? {
    get {return _storage._params}
    set {_uniqueStorage()._params = newValue}
  }

  var init_p: FUInitRequest {
    get {
      if case .init_p(let v)? = _storage._params {return v}
      return FUInitRequest()
    }
    set {_uniqueStorage()._params = .init_p(newValue)}
  }

  var data: FUDataRequest {
    get {
      if case .data(let v)? = _storage._params {return v}
      return FUDataRequest()
    }
    set {_uniqueStorage()._params = .data(newValue)}
  }

  var exit: FUExitRequest {
    get {
      if case .exit(let v)? = _storage._params {return v}
      return FUExitRequest()
    }
    set {_uniqueStorage()._params = .exit(newValue)}
  }

  var desc: Bool {
    get {
      if case .desc(let v)? = _storage._params {return v}
      return false
    }
    set {_uniqueStorage()._params = .desc(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Params: Equatable {
    case init_p(FUInitRequest)
    case data(FUDataRequest)
    case exit(FUExitRequest)
    case desc(Bool)

  #if !swift(>=4.1)
    static func ==(lhs: FilesUpdateRequest.OneOf_Params, rhs: FilesUpdateRequest.OneOf_Params) -> Bool {
      switch (lhs, rhs) {
      case (.init_p(let l), .init_p(let r)): return l == r
      case (.data(let l), .data(let r)): return l == r
      case (.exit(let l), .exit(let r)): return l == r
      case (.desc(let l), .desc(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension FUType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GPS"),
    1: .same(proto: "FONT"),
    2: .same(proto: "MGAONLINE"),
    3: .same(proto: "CUSTOMDIAL"),
    4: .same(proto: "FIRMWARE"),
  ]
}

extension FUInitResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FUInitResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fd"),
    2: .same(proto: "status"),
  ]

  public var isInitialized: Bool {
    if self._fd == nil {return false}
    if self._status == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._fd)
      case 2: try decoder.decodeSingularEnumField(value: &self._status)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._fd {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FUInitResponse, rhs: FUInitResponse) -> Bool {
    if lhs._fd != rhs._fd {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FUInitResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "ERROR_PARAMS"),
    2: .same(proto: "ERROR_INNER"),
  ]
}

extension FUDataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FUDataResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fd"),
    2: .same(proto: "status"),
    3: .standard(proto: "file_offset"),
    4: .standard(proto: "crc32_at_offset"),
  ]

  public var isInitialized: Bool {
    if self._fd == nil {return false}
    if self._status == nil {return false}
    if self._fileOffset == nil {return false}
    if self._crc32AtOffset == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._fd)
      case 2: try decoder.decodeSingularEnumField(value: &self._status)
      case 3: try decoder.decodeSingularFixed32Field(value: &self._fileOffset)
      case 4: try decoder.decodeSingularFixed32Field(value: &self._crc32AtOffset)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._fd {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }
    if let v = self._fileOffset {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    }
    if let v = self._crc32AtOffset {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FUDataResponse, rhs: FUDataResponse) -> Bool {
    if lhs._fd != rhs._fd {return false}
    if lhs._status != rhs._status {return false}
    if lhs._fileOffset != rhs._fileOffset {return false}
    if lhs._crc32AtOffset != rhs._crc32AtOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FUDataResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "ERROR_PARAMS"),
    2: .same(proto: "ERROR_OFFSET_MISMATCH"),
    3: .same(proto: "ERROR_CRC32_MISMATCH"),
    4: .same(proto: "ERROR_INNER"),
  ]
}

extension FUFileInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FUFileInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fd"),
    2: .standard(proto: "file_name"),
    3: .standard(proto: "file_size"),
    4: .standard(proto: "file_crc32"),
    5: .standard(proto: "file_offset"),
    6: .standard(proto: "crc32_at_offset"),
  ]

  public var isInitialized: Bool {
    if self._fd == nil {return false}
    if self._fileName == nil {return false}
    if self._fileSize == nil {return false}
    if self._fileCrc32 == nil {return false}
    if self._fileOffset == nil {return false}
    if self._crc32AtOffset == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._fd)
      case 2: try decoder.decodeSingularStringField(value: &self._fileName)
      case 3: try decoder.decodeSingularFixed32Field(value: &self._fileSize)
      case 4: try decoder.decodeSingularFixed32Field(value: &self._fileCrc32)
      case 5: try decoder.decodeSingularFixed32Field(value: &self._fileOffset)
      case 6: try decoder.decodeSingularFixed32Field(value: &self._crc32AtOffset)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._fd {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._fileName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._fileSize {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    }
    if let v = self._fileCrc32 {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    }
    if let v = self._fileOffset {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 5)
    }
    if let v = self._crc32AtOffset {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FUFileInfo, rhs: FUFileInfo) -> Bool {
    if lhs._fd != rhs._fd {return false}
    if lhs._fileName != rhs._fileName {return false}
    if lhs._fileSize != rhs._fileSize {return false}
    if lhs._fileCrc32 != rhs._fileCrc32 {return false}
    if lhs._fileOffset != rhs._fileOffset {return false}
    if lhs._crc32AtOffset != rhs._crc32AtOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FUFileDesc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FUFileDesc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_size"),
    2: .same(proto: "valid"),
    3: .same(proto: "info"),
  ]

  fileprivate class _StorageClass {
    var _maxSize: UInt32? = nil
    var _valid: Bool? = nil
    var _info: FUFileInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _maxSize = source._maxSize
      _valid = source._valid
      _info = source._info
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._maxSize == nil {return false}
      if _storage._valid == nil {return false}
      if _storage._info == nil {return false}
      if let v = _storage._info, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularFixed32Field(value: &_storage._maxSize)
        case 2: try decoder.decodeSingularBoolField(value: &_storage._valid)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._info)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._maxSize {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
      }
      if let v = _storage._valid {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      }
      if let v = _storage._info {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FUFileDesc, rhs: FUFileDesc) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._maxSize != rhs_storage._maxSize {return false}
        if _storage._valid != rhs_storage._valid {return false}
        if _storage._info != rhs_storage._info {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FUExitResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FUExitResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fd"),
    2: .same(proto: "status"),
    3: .same(proto: "desc"),
  ]

  fileprivate class _StorageClass {
    var _fd: FUType? = nil
    var _status: FUExitResponse.Status? = nil
    var _desc: FUFileDesc? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _fd = source._fd
      _status = source._status
      _desc = source._desc
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._fd == nil {return false}
      if _storage._status == nil {return false}
      if _storage._desc == nil {return false}
      if let v = _storage._desc, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._fd)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._status)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._desc)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._fd {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      }
      if let v = _storage._status {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      }
      if let v = _storage._desc {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FUExitResponse, rhs: FUExitResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._fd != rhs_storage._fd {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._desc != rhs_storage._desc {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FUExitResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "ERROR_PARAMS"),
    2: .same(proto: "ERROR_CRC_MISMATCH"),
    3: .same(proto: "ERROR_SIZE_MISMATCH"),
    4: .same(proto: "ERROR_INNER"),
  ]
}

extension FUDescResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FUDescResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mtu"),
    2: .same(proto: "gps"),
    3: .same(proto: "font"),
    4: .same(proto: "mgaonline"),
    5: .same(proto: "customdial"),
    6: .same(proto: "firmware"),
  ]

  fileprivate class _StorageClass {
    var _mtu: UInt32? = nil
    var _gps: FUFileDesc? = nil
    var _font: FUFileDesc? = nil
    var _mgaonline: FUFileDesc? = nil
    var _customdial: FUFileDesc? = nil
    var _firmware: FUFileDesc? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _mtu = source._mtu
      _gps = source._gps
      _font = source._font
      _mgaonline = source._mgaonline
      _customdial = source._customdial
      _firmware = source._firmware
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._mtu == nil {return false}
      if let v = _storage._gps, !v.isInitialized {return false}
      if let v = _storage._font, !v.isInitialized {return false}
      if let v = _storage._mgaonline, !v.isInitialized {return false}
      if let v = _storage._customdial, !v.isInitialized {return false}
      if let v = _storage._firmware, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularFixed32Field(value: &_storage._mtu)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._gps)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._font)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._mgaonline)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._customdial)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._firmware)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._mtu {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
      }
      if let v = _storage._gps {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._font {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._mgaonline {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._customdial {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._firmware {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FUDescResponse, rhs: FUDescResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._mtu != rhs_storage._mtu {return false}
        if _storage._gps != rhs_storage._gps {return false}
        if _storage._font != rhs_storage._font {return false}
        if _storage._mgaonline != rhs_storage._mgaonline {return false}
        if _storage._customdial != rhs_storage._customdial {return false}
        if _storage._firmware != rhs_storage._firmware {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilesUpdateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FilesUpdateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "init"),
    2: .same(proto: "data"),
    3: .same(proto: "exit"),
    4: .same(proto: "desc"),
  ]

  fileprivate class _StorageClass {
    var _params: FilesUpdateResponse.OneOf_Params?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _params = source._params
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._params {
      case .init_p(let v)?: if !v.isInitialized {return false}
      case .data(let v)?: if !v.isInitialized {return false}
      case .exit(let v)?: if !v.isInitialized {return false}
      case .desc(let v)?: if !v.isInitialized {return false}
      default: break
      }
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: FUInitResponse?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .init_p(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .init_p(v)}
        case 2:
          var v: FUDataResponse?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .data(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .data(v)}
        case 3:
          var v: FUExitResponse?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .exit(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .exit(v)}
        case 4:
          var v: FUDescResponse?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .desc(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .desc(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._params {
      case .init_p(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .data(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .exit(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .desc(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FilesUpdateResponse, rhs: FilesUpdateResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._params != rhs_storage._params {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FUInitRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FUInitRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "init_info"),
  ]

  fileprivate class _StorageClass {
    var _initInfo: FUFileInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _initInfo = source._initInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._initInfo == nil {return false}
      if let v = _storage._initInfo, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._initInfo)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._initInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FUInitRequest, rhs: FUInitRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._initInfo != rhs_storage._initInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FUDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FUDataRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fd"),
    2: .standard(proto: "file_offset"),
    3: .standard(proto: "crc32_at_offset"),
    4: .same(proto: "buf"),
  ]

  public var isInitialized: Bool {
    if self._fd == nil {return false}
    if self._fileOffset == nil {return false}
    if self._crc32AtOffset == nil {return false}
    if self._buf == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._fd)
      case 2: try decoder.decodeSingularFixed32Field(value: &self._fileOffset)
      case 3: try decoder.decodeSingularFixed32Field(value: &self._crc32AtOffset)
      case 4: try decoder.decodeSingularBytesField(value: &self._buf)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._fd {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._fileOffset {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    }
    if let v = self._crc32AtOffset {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    }
    if let v = self._buf {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FUDataRequest, rhs: FUDataRequest) -> Bool {
    if lhs._fd != rhs._fd {return false}
    if lhs._fileOffset != rhs._fileOffset {return false}
    if lhs._crc32AtOffset != rhs._crc32AtOffset {return false}
    if lhs._buf != rhs._buf {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FUExitRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FUExitRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fd"),
  ]

  public var isInitialized: Bool {
    if self._fd == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._fd)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._fd {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FUExitRequest, rhs: FUExitRequest) -> Bool {
    if lhs._fd != rhs._fd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilesUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FilesUpdateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "init"),
    2: .same(proto: "data"),
    3: .same(proto: "exit"),
    4: .same(proto: "desc"),
  ]

  fileprivate class _StorageClass {
    var _params: FilesUpdateRequest.OneOf_Params?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _params = source._params
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._params {
      case .init_p(let v)?: if !v.isInitialized {return false}
      case .data(let v)?: if !v.isInitialized {return false}
      case .exit(let v)?: if !v.isInitialized {return false}
      default: break
      }
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: FUInitRequest?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .init_p(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .init_p(v)}
        case 2:
          var v: FUDataRequest?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .data(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .data(v)}
        case 3:
          var v: FUExitRequest?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .exit(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .exit(v)}
        case 4:
          if _storage._params != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._params = .desc(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._params {
      case .init_p(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .data(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .exit(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .desc(let v)?:
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FilesUpdateRequest, rhs: FilesUpdateRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._params != rhs_storage._params {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
