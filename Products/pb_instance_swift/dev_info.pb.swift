// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: dev_info.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum DevInfoFota: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case non // = 0
  case cc2540 // = 1
  case nrf51 // = 2
  case da1468X // = 3
  case mt2523 // = 4
  case nrf52Ble // = 5
  case nrf52Serial // = 6

  init() {
    self = .non
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .non
    case 1: self = .cc2540
    case 2: self = .nrf51
    case 3: self = .da1468X
    case 4: self = .mt2523
    case 5: self = .nrf52Ble
    case 6: self = .nrf52Serial
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .non: return 0
    case .cc2540: return 1
    case .nrf51: return 2
    case .da1468X: return 3
    case .mt2523: return 4
    case .nrf52Ble: return 5
    case .nrf52Serial: return 6
    }
  }

}

#if swift(>=4.2)

extension DevInfoFota: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum DevInfoOperation: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case read // = 0
  case write // = 1

  init() {
    self = .read
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .read
    case 1: self = .write
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .read: return 0
    case .write: return 1
    }
  }

}

#if swift(>=4.2)

extension DevInfoOperation: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct DevInfoManu {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var date: String {
    get {return _date ?? String()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  mutating func clearDate() {self._date = nil}

  var factory: String {
    get {return _factory ?? String()}
    set {_factory = newValue}
  }
  /// Returns true if `factory` has been explicitly set.
  var hasFactory: Bool {return self._factory != nil}
  /// Clears the value of `factory`. Subsequent reads from it will return its default value.
  mutating func clearFactory() {self._factory = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _date: String? = nil
  fileprivate var _factory: String? = nil
}

struct DeviceInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var model: String {
    get {return _storage._model ?? String()}
    set {_uniqueStorage()._model = newValue}
  }
  /// Returns true if `model` has been explicitly set.
  var hasModel: Bool {return _storage._model != nil}
  /// Clears the value of `model`. Subsequent reads from it will return its default value.
  mutating func clearModel() {_uniqueStorage()._model = nil}

  var version: String {
    get {return _storage._version ?? String()}
    set {_uniqueStorage()._version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return _storage._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {_uniqueStorage()._version = nil}

  var mac: Data {
    get {return _storage._mac ?? SwiftProtobuf.Internal.emptyData}
    set {_uniqueStorage()._mac = newValue}
  }
  /// Returns true if `mac` has been explicitly set.
  var hasMac: Bool {return _storage._mac != nil}
  /// Clears the value of `mac`. Subsequent reads from it will return its default value.
  mutating func clearMac() {_uniqueStorage()._mac = nil}

  var fota: DevInfoFota {
    get {return _storage._fota ?? .non}
    set {_uniqueStorage()._fota = newValue}
  }
  /// Returns true if `fota` has been explicitly set.
  var hasFota: Bool {return _storage._fota != nil}
  /// Clears the value of `fota`. Subsequent reads from it will return its default value.
  mutating func clearFota() {_uniqueStorage()._fota = nil}

  var manu: DevInfoManu {
    get {return _storage._manu ?? DevInfoManu()}
    set {_uniqueStorage()._manu = newValue}
  }
  /// Returns true if `manu` has been explicitly set.
  var hasManu: Bool {return _storage._manu != nil}
  /// Clears the value of `manu`. Subsequent reads from it will return its default value.
  mutating func clearManu() {_uniqueStorage()._manu = nil}

  var userData: Data {
    get {return _storage._userData ?? SwiftProtobuf.Internal.emptyData}
    set {_uniqueStorage()._userData = newValue}
  }
  /// Returns true if `userData` has been explicitly set.
  var hasUserData: Bool {return _storage._userData != nil}
  /// Clears the value of `userData`. Subsequent reads from it will return its default value.
  mutating func clearUserData() {_uniqueStorage()._userData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct DeviceInfoCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userData: Data {
    get {return _userData ?? SwiftProtobuf.Internal.emptyData}
    set {_userData = newValue}
  }
  /// Returns true if `userData` has been explicitly set.
  var hasUserData: Bool {return self._userData != nil}
  /// Clears the value of `userData`. Subsequent reads from it will return its default value.
  mutating func clearUserData() {self._userData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _userData: Data? = nil
}

struct DeviceInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reserved: UInt32 {
    get {return _storage._reserved ?? 0}
    set {_uniqueStorage()._reserved = newValue}
  }
  /// Returns true if `reserved` has been explicitly set.
  var hasReserved: Bool {return _storage._reserved != nil}
  /// Clears the value of `reserved`. Subsequent reads from it will return its default value.
  mutating func clearReserved() {_uniqueStorage()._reserved = nil}

  var operation: DevInfoOperation {
    get {return _storage._operation ?? .read}
    set {_uniqueStorage()._operation = newValue}
  }
  /// Returns true if `operation` has been explicitly set.
  var hasOperation: Bool {return _storage._operation != nil}
  /// Clears the value of `operation`. Subsequent reads from it will return its default value.
  mutating func clearOperation() {_uniqueStorage()._operation = nil}

  var devinfo: DeviceInfoCommand {
    get {return _storage._devinfo ?? DeviceInfoCommand()}
    set {_uniqueStorage()._devinfo = newValue}
  }
  /// Returns true if `devinfo` has been explicitly set.
  var hasDevinfo: Bool {return _storage._devinfo != nil}
  /// Clears the value of `devinfo`. Subsequent reads from it will return its default value.
  mutating func clearDevinfo() {_uniqueStorage()._devinfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension DevInfoFota: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NON"),
    1: .same(proto: "CC2540"),
    2: .same(proto: "NRF51"),
    3: .same(proto: "DA1468X"),
    4: .same(proto: "MT2523"),
    5: .same(proto: "NRF52_BLE"),
    6: .same(proto: "NRF52_SERIAL"),
  ]
}

extension DevInfoOperation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Read"),
    1: .same(proto: "Write"),
  ]
}

extension DevInfoManu: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DevInfoManu"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .same(proto: "factory"),
  ]

  public var isInitialized: Bool {
    if self._date == nil {return false}
    if self._factory == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._date)
      case 2: try decoder.decodeSingularStringField(value: &self._factory)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._date {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._factory {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DevInfoManu, rhs: DevInfoManu) -> Bool {
    if lhs._date != rhs._date {return false}
    if lhs._factory != rhs._factory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeviceInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeviceInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "model"),
    2: .same(proto: "version"),
    3: .same(proto: "mac"),
    4: .same(proto: "fota"),
    5: .same(proto: "manu"),
    6: .standard(proto: "user_data"),
  ]

  fileprivate class _StorageClass {
    var _model: String? = nil
    var _version: String? = nil
    var _mac: Data? = nil
    var _fota: DevInfoFota? = nil
    var _manu: DevInfoManu? = nil
    var _userData: Data? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _model = source._model
      _version = source._version
      _mac = source._mac
      _fota = source._fota
      _manu = source._manu
      _userData = source._userData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._manu, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._model)
        case 2: try decoder.decodeSingularStringField(value: &_storage._version)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._mac)
        case 4: try decoder.decodeSingularEnumField(value: &_storage._fota)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._manu)
        case 6: try decoder.decodeSingularBytesField(value: &_storage._userData)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._model {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._version {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._mac {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
      }
      if let v = _storage._fota {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
      }
      if let v = _storage._manu {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._userData {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeviceInfoResponse, rhs: DeviceInfoResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._model != rhs_storage._model {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._mac != rhs_storage._mac {return false}
        if _storage._fota != rhs_storage._fota {return false}
        if _storage._manu != rhs_storage._manu {return false}
        if _storage._userData != rhs_storage._userData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeviceInfoCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeviceInfoCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self._userData)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._userData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeviceInfoCommand, rhs: DeviceInfoCommand) -> Bool {
    if lhs._userData != rhs._userData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeviceInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeviceInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reserved"),
    2: .same(proto: "operation"),
    3: .same(proto: "devinfo"),
  ]

  fileprivate class _StorageClass {
    var _reserved: UInt32? = nil
    var _operation: DevInfoOperation? = nil
    var _devinfo: DeviceInfoCommand? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _reserved = source._reserved
      _operation = source._operation
      _devinfo = source._devinfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._operation == nil {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularFixed32Field(value: &_storage._reserved)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._operation)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._devinfo)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._reserved {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
      }
      if let v = _storage._operation {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      }
      if let v = _storage._devinfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeviceInfoRequest, rhs: DeviceInfoRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._reserved != rhs_storage._reserved {return false}
        if _storage._operation != rhs_storage._operation {return false}
        if _storage._devinfo != rhs_storage._devinfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
