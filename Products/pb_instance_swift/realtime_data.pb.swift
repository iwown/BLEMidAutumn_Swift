// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: realtime_data.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum RtMode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case backNormal // = 0
  case enterCamera // = 1

  init() {
    self = .backNormal
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .backNormal
    case 1: self = .enterCamera
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .backNormal: return 0
    case .enterCamera: return 1
    }
  }

}

#if swift(>=4.2)

extension RtMode: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum RtKeyEvent: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case rtKeyCamera // = 0

  init() {
    self = .rtKeyCamera
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .rtKeyCamera
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .rtKeyCamera: return 0
    }
  }

}

#if swift(>=4.2)

extension RtKeyEvent: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum RtSync: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case stopAll // = 0
  case onlyOnce // = 1
  case onValueChange // = 2
  case onSecondChange // = 3
  case onMinuteChange // = 4
  case onHourChange // = 5
  case onDayChange // = 6
  case onTenMinuteChange // = 7

  init() {
    self = .stopAll
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .stopAll
    case 1: self = .onlyOnce
    case 2: self = .onValueChange
    case 3: self = .onSecondChange
    case 4: self = .onMinuteChange
    case 5: self = .onHourChange
    case 6: self = .onDayChange
    case 7: self = .onTenMinuteChange
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .stopAll: return 0
    case .onlyOnce: return 1
    case .onValueChange: return 2
    case .onSecondChange: return 3
    case .onMinuteChange: return 4
    case .onHourChange: return 5
    case .onDayChange: return 6
    case .onTenMinuteChange: return 7
    }
  }

}

#if swift(>=4.2)

extension RtSync: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum SensorType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case none // = 0
  case ecg // = 1
  case ppg // = 2
  case mag // = 4
  case gyro // = 8
  case acc // = 16

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .ecg
    case 2: self = .ppg
    case 4: self = .mag
    case 8: self = .gyro
    case 16: self = .acc
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .ecg: return 1
    case .ppg: return 2
    case .mag: return 4
    case .gyro: return 8
    case .acc: return 16
    }
  }

}

#if swift(>=4.2)

extension SensorType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum SensorOperation: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// start sync
  case sensorStartSync // = 0

  /// pause sync
  case sensorPauseSync // = 1

  /// stop sync
  case sensorStopSync // = 2

  init() {
    self = .sensorStartSync
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sensorStartSync
    case 1: self = .sensorPauseSync
    case 2: self = .sensorStopSync
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .sensorStartSync: return 0
    case .sensorPauseSync: return 1
    case .sensorStopSync: return 2
    }
  }

}

#if swift(>=4.2)

extension SensorOperation: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct RtTime {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var seconds: UInt32 {
    get {return _seconds ?? 0}
    set {_seconds = newValue}
  }
  /// Returns true if `seconds` has been explicitly set.
  var hasSeconds: Bool {return self._seconds != nil}
  /// Clears the value of `seconds`. Subsequent reads from it will return its default value.
  mutating func clearSeconds() {self._seconds = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _seconds: UInt32? = nil
}

struct DateTime {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dateTime: RtTime {
    get {return _storage._dateTime ?? RtTime()}
    set {_uniqueStorage()._dateTime = newValue}
  }
  /// Returns true if `dateTime` has been explicitly set.
  var hasDateTime: Bool {return _storage._dateTime != nil}
  /// Clears the value of `dateTime`. Subsequent reads from it will return its default value.
  mutating func clearDateTime() {_uniqueStorage()._dateTime = nil}

  var timeZone: Int32 {
    get {return _storage._timeZone ?? 0}
    set {_uniqueStorage()._timeZone = newValue}
  }
  /// Returns true if `timeZone` has been explicitly set.
  var hasTimeZone: Bool {return _storage._timeZone != nil}
  /// Clears the value of `timeZone`. Subsequent reads from it will return its default value.
  mutating func clearTimeZone() {_uniqueStorage()._timeZone = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct RtBattery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///0~9
  var level: UInt32 {
    get {return _level ?? 0}
    set {_level = newValue}
  }
  /// Returns true if `level` has been explicitly set.
  var hasLevel: Bool {return self._level != nil}
  /// Clears the value of `level`. Subsequent reads from it will return its default value.
  mutating func clearLevel() {self._level = nil}

  var charging: Bool {
    get {return _charging ?? false}
    set {_charging = newValue}
  }
  /// Returns true if `charging` has been explicitly set.
  var hasCharging: Bool {return self._charging != nil}
  /// Clears the value of `charging`. Subsequent reads from it will return its default value.
  mutating func clearCharging() {self._charging = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _level: UInt32? = nil
  fileprivate var _charging: Bool? = nil
}

struct RtHealth {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var steps: UInt32 {
    get {return _steps ?? 0}
    set {_steps = newValue}
  }
  /// Returns true if `steps` has been explicitly set.
  var hasSteps: Bool {return self._steps != nil}
  /// Clears the value of `steps`. Subsequent reads from it will return its default value.
  mutating func clearSteps() {self._steps = nil}

  var distance: UInt32 {
    get {return _distance ?? 0}
    set {_distance = newValue}
  }
  /// Returns true if `distance` has been explicitly set.
  var hasDistance: Bool {return self._distance != nil}
  /// Clears the value of `distance`. Subsequent reads from it will return its default value.
  mutating func clearDistance() {self._distance = nil}

  var calorie: UInt32 {
    get {return _calorie ?? 0}
    set {_calorie = newValue}
  }
  /// Returns true if `calorie` has been explicitly set.
  var hasCalorie: Bool {return self._calorie != nil}
  /// Clears the value of `calorie`. Subsequent reads from it will return its default value.
  mutating func clearCalorie() {self._calorie = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _steps: UInt32? = nil
  fileprivate var _distance: UInt32? = nil
  fileprivate var _calorie: UInt32? = nil
}

struct RtGNSS {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var longitude: Float {
    get {return _longitude ?? 0}
    set {_longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  var hasLongitude: Bool {return self._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  mutating func clearLongitude() {self._longitude = nil}

  var latitude: Float {
    get {return _latitude ?? 0}
    set {_latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  var hasLatitude: Bool {return self._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  mutating func clearLatitude() {self._latitude = nil}

  /// m/s
  var speed: Float {
    get {return _speed ?? 0}
    set {_speed = newValue}
  }
  /// Returns true if `speed` has been explicitly set.
  var hasSpeed: Bool {return self._speed != nil}
  /// Clears the value of `speed`. Subsequent reads from it will return its default value.
  mutating func clearSpeed() {self._speed = nil}

  /// m
  var altitude: Float {
    get {return _altitude ?? 0}
    set {_altitude = newValue}
  }
  /// Returns true if `altitude` has been explicitly set.
  var hasAltitude: Bool {return self._altitude != nil}
  /// Clears the value of `altitude`. Subsequent reads from it will return its default value.
  mutating func clearAltitude() {self._altitude = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _longitude: Float? = nil
  fileprivate var _latitude: Float? = nil
  fileprivate var _speed: Float? = nil
  fileprivate var _altitude: Float? = nil
}

struct RtSensor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var operation: SensorOperation {
    get {return _operation ?? .sensorStartSync}
    set {_operation = newValue}
  }
  /// Returns true if `operation` has been explicitly set.
  var hasOperation: Bool {return self._operation != nil}
  /// Clears the value of `operation`. Subsequent reads from it will return its default value.
  mutating func clearOperation() {self._operation = nil}

  var type: UInt32 {
    get {return _type ?? 0}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _operation: SensorOperation? = nil
  fileprivate var _type: UInt32? = nil
}

struct RtSubscriber {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var time: RtSync {
    get {return _storage._time ?? .stopAll}
    set {_uniqueStorage()._time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return _storage._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {_uniqueStorage()._time = nil}

  var battery: RtSync {
    get {return _storage._battery ?? .stopAll}
    set {_uniqueStorage()._battery = newValue}
  }
  /// Returns true if `battery` has been explicitly set.
  var hasBattery: Bool {return _storage._battery != nil}
  /// Clears the value of `battery`. Subsequent reads from it will return its default value.
  mutating func clearBattery() {_uniqueStorage()._battery = nil}

  var health: RtSync {
    get {return _storage._health ?? .stopAll}
    set {_uniqueStorage()._health = newValue}
  }
  /// Returns true if `health` has been explicitly set.
  var hasHealth: Bool {return _storage._health != nil}
  /// Clears the value of `health`. Subsequent reads from it will return its default value.
  mutating func clearHealth() {_uniqueStorage()._health = nil}

  var mode: RtMode {
    get {return _storage._mode ?? .backNormal}
    set {_uniqueStorage()._mode = newValue}
  }
  /// Returns true if `mode` has been explicitly set.
  var hasMode: Bool {return _storage._mode != nil}
  /// Clears the value of `mode`. Subsequent reads from it will return its default value.
  mutating func clearMode() {_uniqueStorage()._mode = nil}

  var sensor: RtSensor {
    get {return _storage._sensor ?? RtSensor()}
    set {_uniqueStorage()._sensor = newValue}
  }
  /// Returns true if `sensor` has been explicitly set.
  var hasSensor: Bool {return _storage._sensor != nil}
  /// Clears the value of `sensor`. Subsequent reads from it will return its default value.
  mutating func clearSensor() {_uniqueStorage()._sensor = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct RtData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var time: RtTime {
    get {return _storage._time ?? RtTime()}
    set {_uniqueStorage()._time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return _storage._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {_uniqueStorage()._time = nil}

  var battery: RtBattery {
    get {return _storage._battery ?? RtBattery()}
    set {_uniqueStorage()._battery = newValue}
  }
  /// Returns true if `battery` has been explicitly set.
  var hasBattery: Bool {return _storage._battery != nil}
  /// Clears the value of `battery`. Subsequent reads from it will return its default value.
  mutating func clearBattery() {_uniqueStorage()._battery = nil}

  var health: RtHealth {
    get {return _storage._health ?? RtHealth()}
    set {_uniqueStorage()._health = newValue}
  }
  /// Returns true if `health` has been explicitly set.
  var hasHealth: Bool {return _storage._health != nil}
  /// Clears the value of `health`. Subsequent reads from it will return its default value.
  mutating func clearHealth() {_uniqueStorage()._health = nil}

  var key: RtKeyEvent {
    get {return _storage._key ?? .rtKeyCamera}
    set {_uniqueStorage()._key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return _storage._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {_uniqueStorage()._key = nil}

  var timeZone: Int32 {
    get {return _storage._timeZone ?? 0}
    set {_uniqueStorage()._timeZone = newValue}
  }
  /// Returns true if `timeZone` has been explicitly set.
  var hasTimeZone: Bool {return _storage._timeZone != nil}
  /// Clears the value of `timeZone`. Subsequent reads from it will return its default value.
  mutating func clearTimeZone() {_uniqueStorage()._timeZone = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct RtState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var time: RtSync {
    get {return _time ?? .stopAll}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  var battery: RtSync {
    get {return _battery ?? .stopAll}
    set {_battery = newValue}
  }
  /// Returns true if `battery` has been explicitly set.
  var hasBattery: Bool {return self._battery != nil}
  /// Clears the value of `battery`. Subsequent reads from it will return its default value.
  mutating func clearBattery() {self._battery = nil}

  var health: RtSync {
    get {return _health ?? .stopAll}
    set {_health = newValue}
  }
  /// Returns true if `health` has been explicitly set.
  var hasHealth: Bool {return self._health != nil}
  /// Clears the value of `health`. Subsequent reads from it will return its default value.
  mutating func clearHealth() {self._health = nil}

  var mode: RtMode {
    get {return _mode ?? .backNormal}
    set {_mode = newValue}
  }
  /// Returns true if `mode` has been explicitly set.
  var hasMode: Bool {return self._mode != nil}
  /// Clears the value of `mode`. Subsequent reads from it will return its default value.
  mutating func clearMode() {self._mode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _time: RtSync? = nil
  fileprivate var _battery: RtSync? = nil
  fileprivate var _health: RtSync? = nil
  fileprivate var _mode: RtMode? = nil
}

struct RtSensorData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: UInt32 {
    get {return _storage._type ?? 0}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  var time: RtTime {
    get {return _storage._time ?? RtTime()}
    set {_uniqueStorage()._time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return _storage._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {_uniqueStorage()._time = nil}

  var seq: UInt32 {
    get {return _storage._seq ?? 0}
    set {_uniqueStorage()._seq = newValue}
  }
  /// Returns true if `seq` has been explicitly set.
  var hasSeq: Bool {return _storage._seq != nil}
  /// Clears the value of `seq`. Subsequent reads from it will return its default value.
  mutating func clearSeq() {_uniqueStorage()._seq = nil}

  var data: [UInt32] {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct RtNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: OneOf_Data? {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  var rtData: RtData {
    get {
      if case .rtData(let v)? = _storage._data {return v}
      return RtData()
    }
    set {_uniqueStorage()._data = .rtData(newValue)}
  }

  var rtState: RtState {
    get {
      if case .rtState(let v)? = _storage._data {return v}
      return RtState()
    }
    set {_uniqueStorage()._data = .rtState(newValue)}
  }

  var rtSensordata: RtSensorData {
    get {
      if case .rtSensordata(let v)? = _storage._data {return v}
      return RtSensorData()
    }
    set {_uniqueStorage()._data = .rtSensordata(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Data: Equatable {
    case rtData(RtData)
    case rtState(RtState)
    case rtSensordata(RtSensorData)

  #if !swift(>=4.1)
    static func ==(lhs: RtNotification.OneOf_Data, rhs: RtNotification.OneOf_Data) -> Bool {
      switch (lhs, rhs) {
      case (.rtData(let l), .rtData(let r)): return l == r
      case (.rtState(let l), .rtState(let r)): return l == r
      case (.rtSensordata(let l), .rtSensordata(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension RtMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RT_MODE_BACK_NORMAL"),
    1: .same(proto: "RT_MODE_ENTER_CAMERA"),
  ]
}

extension RtKeyEvent: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RT_KEY_CAMERA"),
  ]
}

extension RtSync: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STOP_ALL"),
    1: .same(proto: "ONLY_ONCE"),
    2: .same(proto: "ON_VALUE_CHANGE"),
    3: .same(proto: "ON_SECOND_CHANGE"),
    4: .same(proto: "ON_MINUTE_CHANGE"),
    5: .same(proto: "ON_HOUR_CHANGE"),
    6: .same(proto: "ON_DAY_CHANGE"),
    7: .same(proto: "ON_TEN_MINUTE_CHANGE"),
  ]
}

extension SensorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "ECG"),
    2: .same(proto: "PPG"),
    4: .same(proto: "MAG"),
    8: .same(proto: "GYRO"),
    16: .same(proto: "ACC"),
  ]
}

extension SensorOperation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SENSOR_START_SYNC"),
    1: .same(proto: "SENSOR_PAUSE_SYNC"),
    2: .same(proto: "SENSOR_STOP_SYNC"),
  ]
}

extension RtTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RtTime"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seconds"),
  ]

  public var isInitialized: Bool {
    if self._seconds == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFixed32Field(value: &self._seconds)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._seconds {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RtTime, rhs: RtTime) -> Bool {
    if lhs._seconds != rhs._seconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DateTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DateTime"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "date_time"),
    2: .standard(proto: "time_zone"),
  ]

  fileprivate class _StorageClass {
    var _dateTime: RtTime? = nil
    var _timeZone: Int32? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _dateTime = source._dateTime
      _timeZone = source._timeZone
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._dateTime == nil {return false}
      if _storage._timeZone == nil {return false}
      if let v = _storage._dateTime, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._dateTime)
        case 2: try decoder.decodeSingularSFixed32Field(value: &_storage._timeZone)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._dateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._timeZone {
        try visitor.visitSingularSFixed32Field(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DateTime, rhs: DateTime) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._dateTime != rhs_storage._dateTime {return false}
        if _storage._timeZone != rhs_storage._timeZone {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RtBattery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RtBattery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "level"),
    2: .same(proto: "charging"),
  ]

  public var isInitialized: Bool {
    if self._level == nil {return false}
    if self._charging == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFixed32Field(value: &self._level)
      case 2: try decoder.decodeSingularBoolField(value: &self._charging)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._level {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    }
    if let v = self._charging {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RtBattery, rhs: RtBattery) -> Bool {
    if lhs._level != rhs._level {return false}
    if lhs._charging != rhs._charging {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RtHealth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RtHealth"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "steps"),
    2: .same(proto: "distance"),
    3: .same(proto: "calorie"),
  ]

  public var isInitialized: Bool {
    if self._steps == nil {return false}
    if self._distance == nil {return false}
    if self._calorie == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFixed32Field(value: &self._steps)
      case 2: try decoder.decodeSingularFixed32Field(value: &self._distance)
      case 3: try decoder.decodeSingularFixed32Field(value: &self._calorie)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._steps {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    }
    if let v = self._distance {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    }
    if let v = self._calorie {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RtHealth, rhs: RtHealth) -> Bool {
    if lhs._steps != rhs._steps {return false}
    if lhs._distance != rhs._distance {return false}
    if lhs._calorie != rhs._calorie {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RtGNSS: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RtGNSS"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "longitude"),
    2: .same(proto: "latitude"),
    3: .same(proto: "speed"),
    4: .same(proto: "altitude"),
  ]

  public var isInitialized: Bool {
    if self._longitude == nil {return false}
    if self._latitude == nil {return false}
    if self._speed == nil {return false}
    if self._altitude == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self._longitude)
      case 2: try decoder.decodeSingularFloatField(value: &self._latitude)
      case 3: try decoder.decodeSingularFloatField(value: &self._speed)
      case 4: try decoder.decodeSingularFloatField(value: &self._altitude)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._longitude {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    }
    if let v = self._latitude {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    }
    if let v = self._speed {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    }
    if let v = self._altitude {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RtGNSS, rhs: RtGNSS) -> Bool {
    if lhs._longitude != rhs._longitude {return false}
    if lhs._latitude != rhs._latitude {return false}
    if lhs._speed != rhs._speed {return false}
    if lhs._altitude != rhs._altitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RtSensor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RtSensor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operation"),
    2: .same(proto: "type"),
  ]

  public var isInitialized: Bool {
    if self._operation == nil {return false}
    if self._type == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._operation)
      case 2: try decoder.decodeSingularFixed32Field(value: &self._type)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._operation {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._type {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RtSensor, rhs: RtSensor) -> Bool {
    if lhs._operation != rhs._operation {return false}
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RtSubscriber: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RtSubscriber"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .same(proto: "battery"),
    3: .same(proto: "health"),
    4: .same(proto: "mode"),
    5: .same(proto: "sensor"),
  ]

  fileprivate class _StorageClass {
    var _time: RtSync? = nil
    var _battery: RtSync? = nil
    var _health: RtSync? = nil
    var _mode: RtMode? = nil
    var _sensor: RtSensor? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _time = source._time
      _battery = source._battery
      _health = source._health
      _mode = source._mode
      _sensor = source._sensor
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._sensor, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._time)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._battery)
        case 3: try decoder.decodeSingularEnumField(value: &_storage._health)
        case 4: try decoder.decodeSingularEnumField(value: &_storage._mode)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._sensor)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._time {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      }
      if let v = _storage._battery {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      }
      if let v = _storage._health {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
      }
      if let v = _storage._mode {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
      }
      if let v = _storage._sensor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RtSubscriber, rhs: RtSubscriber) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._time != rhs_storage._time {return false}
        if _storage._battery != rhs_storage._battery {return false}
        if _storage._health != rhs_storage._health {return false}
        if _storage._mode != rhs_storage._mode {return false}
        if _storage._sensor != rhs_storage._sensor {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RtData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RtData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .same(proto: "battery"),
    3: .same(proto: "health"),
    4: .same(proto: "key"),
    5: .standard(proto: "time_zone"),
  ]

  fileprivate class _StorageClass {
    var _time: RtTime? = nil
    var _battery: RtBattery? = nil
    var _health: RtHealth? = nil
    var _key: RtKeyEvent? = nil
    var _timeZone: Int32? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _time = source._time
      _battery = source._battery
      _health = source._health
      _key = source._key
      _timeZone = source._timeZone
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._time, !v.isInitialized {return false}
      if let v = _storage._battery, !v.isInitialized {return false}
      if let v = _storage._health, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._time)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._battery)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._health)
        case 4: try decoder.decodeSingularEnumField(value: &_storage._key)
        case 5: try decoder.decodeSingularSFixed32Field(value: &_storage._timeZone)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._time {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._battery {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._health {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._key {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
      }
      if let v = _storage._timeZone {
        try visitor.visitSingularSFixed32Field(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RtData, rhs: RtData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._time != rhs_storage._time {return false}
        if _storage._battery != rhs_storage._battery {return false}
        if _storage._health != rhs_storage._health {return false}
        if _storage._key != rhs_storage._key {return false}
        if _storage._timeZone != rhs_storage._timeZone {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RtState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RtState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .same(proto: "battery"),
    3: .same(proto: "health"),
    4: .same(proto: "mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._time)
      case 2: try decoder.decodeSingularEnumField(value: &self._battery)
      case 3: try decoder.decodeSingularEnumField(value: &self._health)
      case 4: try decoder.decodeSingularEnumField(value: &self._mode)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._time {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._battery {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }
    if let v = self._health {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }
    if let v = self._mode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RtState, rhs: RtState) -> Bool {
    if lhs._time != rhs._time {return false}
    if lhs._battery != rhs._battery {return false}
    if lhs._health != rhs._health {return false}
    if lhs._mode != rhs._mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RtSensorData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RtSensorData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "time"),
    3: .same(proto: "seq"),
    4: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _type: UInt32? = nil
    var _time: RtTime? = nil
    var _seq: UInt32? = nil
    var _data: [UInt32] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _time = source._time
      _seq = source._seq
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type == nil {return false}
      if _storage._time == nil {return false}
      if _storage._seq == nil {return false}
      if let v = _storage._time, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularFixed32Field(value: &_storage._type)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._time)
        case 3: try decoder.decodeSingularFixed32Field(value: &_storage._seq)
        case 4: try decoder.decodeRepeatedFixed32Field(value: &_storage._data)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._type {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
      }
      if let v = _storage._time {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._seq {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
      }
      if !_storage._data.isEmpty {
        try visitor.visitRepeatedFixed32Field(value: _storage._data, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RtSensorData, rhs: RtSensorData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._seq != rhs_storage._seq {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RtNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RtNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rt_data"),
    2: .standard(proto: "rt_state"),
    3: .standard(proto: "rt_sensordata"),
  ]

  fileprivate class _StorageClass {
    var _data: RtNotification.OneOf_Data?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._data {
      case .rtData(let v)?: if !v.isInitialized {return false}
      case .rtSensordata(let v)?: if !v.isInitialized {return false}
      default: break
      }
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: RtData?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .rtData(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .rtData(v)}
        case 2:
          var v: RtState?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .rtState(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .rtState(v)}
        case 3:
          var v: RtSensorData?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .rtSensordata(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .rtSensordata(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._data {
      case .rtData(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .rtState(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .rtSensordata(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RtNotification, rhs: RtNotification) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
